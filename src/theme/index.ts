import * as fs from 'fs';
import * as path from 'path';
import {
  DeclarationReflection,
  ProjectReflection,
  Reflection,
  ReflectionKind,
} from 'typedoc/dist/lib/models/reflections/index';
import { UrlMapping } from 'typedoc/dist/lib/output/models/UrlMapping';
import { Renderer } from 'typedoc/dist/lib/output/renderer';
import { DefaultTheme, TemplateMapping } from 'typedoc/dist/lib/output/themes/DefaultTheme';
import { setProps } from './props';
import { getAnchorRef, getMarkdownEngine, IsDocusaurusEnabled } from './utils';

export class MarkdownTheme extends DefaultTheme {
  /**
   * This is mostly a copy of the DefaultTheme method with .html ext switched to .md
   * Builds the url for the the given reflection and all of its children.
   *
   * @param reflection  The reflection the url should be created for.
   * @param urls The array the url should be appended to.
   * @returns The altered urls array.
   */
  public static buildUrls(
    reflection: DeclarationReflection,
    urls: UrlMapping[],
  ): UrlMapping[] {
    const mapping = DefaultTheme.getMapping(reflection);

    if (IsDocusaurusEnabled()) {
      reflection.name = reflection.name.replace(/^\"/, '[').replace(/\"$/, ' Module]');
      if (reflection.kindString) {
        reflection.kindString = reflection.kindString.replace(/External module/, 'Module');
      }
    }

    if (mapping) {
      if (!reflection.url || !DefaultTheme.URL_PREFIX.test(reflection.url)) {
        const url = MarkdownTheme.buildUrl(mapping, reflection);
        urls.push(new UrlMapping(url, reflection, mapping.template));
        reflection.url = url;
        reflection.hasOwnDocument = true;
      }
      if (reflection.children) {
        for (const key in reflection.children) {
          if (reflection.children.hasOwnProperty(key)) {
            const child = reflection.children[key];
            if (mapping.isLeaf) {
              MarkdownTheme.applyAnchorUrl(child, reflection);
            } else {
              MarkdownTheme.buildUrls(child, urls);
            }
          }
        }
      }
    } else if (reflection.parent) {
      MarkdownTheme.applyAnchorUrl(reflection, reflection.parent);
    }

    return urls;
  }

  public static buildUrl(mapping: TemplateMapping, reflection: DeclarationReflection): string {
    if (IsDocusaurusEnabled()) {
      return  'api-' + mapping.directory + '-' + DefaultTheme.getUrl(reflection).replace(/\_/g, '-').replace(/-\./g, '-')
      .replace(/^-/, '').replace(/-$/g, '').replace(/-module-/g, '-') + '.md';
    } else {
      return [mapping.directory, DefaultTheme.getUrl(reflection) + '.md'].join(
        '/',
      );
    }
  }

  /**
   * Similar to DefaultTheme method with added functionality to cater for bitbucket heading and single file anchors
   * Generate an anchor url for the given reflection and all of its children.
   *
   * @param reflection  The reflection an anchor url should be created for.
   * @param container   The nearest reflection having an own document.
   */
  public static applyAnchorUrl(reflection: Reflection, container: Reflection) {
    if (!reflection.url || !DefaultTheme.URL_PREFIX.test(reflection.url)) {
      let anchor = DefaultTheme.getUrl(reflection, container, '.');

      if (reflection['isStatic']) {
        anchor = 'static-' + anchor;
      }

      let anchorRef = anchor;

      if (getMarkdownEngine() === 'bitbucket') {
        let anchorPrefix = '';
        if (reflection.kind === ReflectionKind.ObjectLiteral) {
          anchorPrefix += 'object-literal-';
        }
        reflection.flags.forEach(flag => {
          anchorPrefix += `${flag}-`;
        });
        const prefixRef = getAnchorRef(anchorPrefix);
        const reflectionRef = getAnchorRef(reflection.name);
        anchorRef = `markdown-header-${prefixRef}${reflectionRef}`;
      }

      reflection.url =
        (container.url !== undefined ? container.url : '') + '#' + anchorRef;
      reflection.anchor = anchor;
      reflection.hasOwnDocument = false;
    }

    reflection.traverse((child: any) => {
      if (child instanceof DeclarationReflection) {
        MarkdownTheme.applyAnchorUrl(child, container);
      }
    });
  }

  constructor(renderer: Renderer, basePath: string, options: any) {
    super(renderer, basePath);

    // remove uneccessary plugins
    renderer.removeComponent('assets');
    renderer.removeComponent('javascript-index');
    renderer.removeComponent('toc');
    renderer.removeComponent('pretty-print');

    // assign global theme service props
    setProps(options, this.resources);
  }

  /**
   * Test whether the given path contains a documentation generated by this theme.
   *
   * @param path  The path of the directory that should be tested.
   * @returns     TRUE if the given path seems to be a previous output directory,
   *              otherwise FALSE.
   */
  public isOutputDirectory(outPath: string): boolean {
    const files = fs.readdirSync(outPath);

    return (
        fs.existsSync(path.join(outPath, this.readMeName)) ||
        (files.length === 1 && path.extname(files[0]) === '.md')
      );
  }

  private get readMeName(): string {
    return (IsDocusaurusEnabled() ? 'api-readme.md' : 'README.md');
  }

  /**
   * Map the models of the given project to the desired output files.
   *
   * @param project  The project whose urls should be generated.
   * @returns        A list of [[UrlMapping]] instances defining which models
   *                 should be rendered to which files.
   */
  public getUrls(project: ProjectReflection): UrlMapping[] {
    const urlMappings: UrlMapping[] = [];
    const entryPoint = this.getEntryPoint(project);

    // write home file with additional context
    urlMappings.push(
      new UrlMapping(
        this.readMeName,
        {
          ...entryPoint,
          ...{
            displayReadme: this.application.options.getValue('readme') !== 'none',
            isIndex: true,
          },
        },
        'reflection.hbs',
      ),
    );

    // write children
    if (entryPoint.children) {
      entryPoint.children.forEach((child: DeclarationReflection) => {
        MarkdownTheme.buildUrls(child, urlMappings);
      });
    }

    // write gitbook summary
    if (getMarkdownEngine() === 'gitbook') {
      const navigationChildren = this.getNavigation(project).children;
      if (navigationChildren) {
        const navigation = navigationChildren.map(navigationItem => {
          const dedicatedUrls = navigationItem.dedicatedUrls
            ? navigationItem.dedicatedUrls.map(url => {
                return {
                  title: () => {
                    const urlMapping = urlMappings.find(item => {
                      return item.url === url;
                    });
                    return urlMapping ? urlMapping.model.name : null;
                  },
                  url,
                };
              })
            : null;

          return { ...navigationItem, dedicatedUrls };
        });
        urlMappings.push(new UrlMapping('SUMMARY.md', { navigation }, 'summary.hbs'));
      }
    }
    return urlMappings;
  }
}
